{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = require(\"./oauth2client\");\nconst gaxios_1 = require(\"gaxios\");\nconst util_1 = require(\"../util\");\nexports.IMPERSONATED_ACCOUNT_TYPE = 'impersonated_service_account';\nclass Impersonated extends oauth2client_1.OAuth2Client {\n  /**\n   * Impersonated service account credentials.\n   *\n   * Create a new access token by impersonating another service account.\n   *\n   * Impersonated Credentials allowing credentials issued to a user or\n   * service account to impersonate another. The source project using\n   * Impersonated Credentials must enable the \"IAMCredentials\" API.\n   * Also, the target service account must grant the orginating principal\n   * the \"Service Account Token Creator\" IAM role.\n   *\n   * @param {object} options - The configuration object.\n   * @param {object} [options.sourceClient] the source credential used as to\n   * acquire the impersonated credentials.\n   * @param {string} [options.targetPrincipal] the service account to\n   * impersonate.\n   * @param {string[]} [options.delegates] the chained list of delegates\n   * required to grant the final access_token. If set, the sequence of\n   * identities must have \"Service Account Token Creator\" capability granted to\n   * the preceding identity. For example, if set to [serviceAccountB,\n   * serviceAccountC], the sourceCredential must have the Token Creator role on\n   * serviceAccountB. serviceAccountB must have the Token Creator on\n   * serviceAccountC. Finally, C must have Token Creator on target_principal.\n   * If left unset, sourceCredential must have that role on targetPrincipal.\n   * @param {string[]} [options.targetScopes] scopes to request during the\n   * authorization grant.\n   * @param {number} [options.lifetime] number of seconds the delegated\n   * credential should be valid for up to 3600 seconds by default, or 43,200\n   * seconds by extending the token's lifetime, see:\n   * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n   * @param {string} [options.endpoint] api endpoint override.\n   */\n  constructor(options = {}) {\n    var _a, _b, _c, _d, _e, _f;\n    super(options);\n    // Start with an expired refresh token, which will automatically be\n    // refreshed before the first API call is made.\n    this.credentials = {\n      expiry_date: 1,\n      refresh_token: 'impersonated-placeholder'\n    };\n    this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n    this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : '';\n    this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n    this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n    this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n    const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get('universe_domain');\n    if (!usingExplicitUniverseDomain) {\n      // override the default universe with the source's universe\n      this.universeDomain = this.sourceClient.universeDomain;\n    } else if (this.sourceClient.universeDomain !== this.universeDomain) {\n      // non-default universe and is not matching the source - this could be a credential leak\n      throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);\n    }\n    this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : `https://iamcredentials.${this.universeDomain}`;\n  }\n  /**\n   * Signs some bytes.\n   *\n   * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}\n   * @param blobToSign String to sign.\n   *\n   * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string\n   */\n  async sign(blobToSign) {\n    await this.sourceClient.getAccessToken();\n    const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n    const u = `${this.endpoint}/v1/${name}:signBlob`;\n    const body = {\n      delegates: this.delegates,\n      payload: Buffer.from(blobToSign).toString('base64')\n    };\n    const res = await this.sourceClient.request({\n      ...Impersonated.RETRY_CONFIG,\n      url: u,\n      data: body,\n      method: 'POST'\n    });\n    return res.data;\n  }\n  /** The service account email to be impersonated. */\n  getTargetPrincipal() {\n    return this.targetPrincipal;\n  }\n  /**\n   * Refreshes the access token.\n   */\n  async refreshToken() {\n    var _a, _b, _c, _d, _e, _f;\n    try {\n      await this.sourceClient.getAccessToken();\n      const name = 'projects/-/serviceAccounts/' + this.targetPrincipal;\n      const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n      const body = {\n        delegates: this.delegates,\n        scope: this.targetScopes,\n        lifetime: this.lifetime + 's'\n      };\n      const res = await this.sourceClient.request({\n        ...Impersonated.RETRY_CONFIG,\n        url: u,\n        data: body,\n        method: 'POST'\n      });\n      const tokenResponse = res.data;\n      this.credentials.access_token = tokenResponse.accessToken;\n      this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n      return {\n        tokens: this.credentials,\n        res\n      };\n    } catch (error) {\n      if (!(error instanceof Error)) throw error;\n      let status = 0;\n      let message = '';\n      if (error instanceof gaxios_1.GaxiosError) {\n        status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n        message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n      }\n      if (status && message) {\n        error.message = `${status}: unable to impersonate: ${message}`;\n        throw error;\n      } else {\n        error.message = `unable to impersonate: ${error}`;\n        throw error;\n      }\n    }\n  }\n  /**\n   * Generates an OpenID Connect ID token for a service account.\n   *\n   * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n   *\n   * @param targetAudience the audience for the fetched ID token.\n   * @param options the for the request\n   * @return an OpenID Connect ID token\n   */\n  async fetchIdToken(targetAudience, options) {\n    var _a, _b;\n    await this.sourceClient.getAccessToken();\n    const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n    const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n    const body = {\n      delegates: this.delegates,\n      audience: targetAudience,\n      includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true,\n      useEmailAzp: (_b = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _b !== void 0 ? _b : true\n    };\n    const res = await this.sourceClient.request({\n      ...Impersonated.RETRY_CONFIG,\n      url: u,\n      data: body,\n      method: 'POST'\n    });\n    return res.data.token;\n  }\n}\nexports.Impersonated = Impersonated;","map":{"version":3,"names":["Object","defineProperty","exports","value","Impersonated","IMPERSONATED_ACCOUNT_TYPE","oauth2client_1","require","gaxios_1","util_1","OAuth2Client","constructor","options","_a","_b","_c","_d","_e","_f","credentials","expiry_date","refresh_token","sourceClient","targetPrincipal","delegates","targetScopes","lifetime","usingExplicitUniverseDomain","originalOrCamelOptions","get","universeDomain","RangeError","endpoint","sign","blobToSign","getAccessToken","name","u","body","payload","Buffer","from","toString","res","request","RETRY_CONFIG","url","data","method","getTargetPrincipal","refreshToken","scope","tokenResponse","access_token","accessToken","Date","parse","expireTime","tokens","error","Error","status","message","GaxiosError","response","fetchIdToken","targetAudience","audience","includeEmail","useEmailAzp","token"],"sources":["C:/Users/panki/OneDrive/Робочий стіл/pizza-app/node_modules/google-auth-library/build/src/auth/impersonated.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = require(\"./oauth2client\");\nconst gaxios_1 = require(\"gaxios\");\nconst util_1 = require(\"../util\");\nexports.IMPERSONATED_ACCOUNT_TYPE = 'impersonated_service_account';\nclass Impersonated extends oauth2client_1.OAuth2Client {\n    /**\n     * Impersonated service account credentials.\n     *\n     * Create a new access token by impersonating another service account.\n     *\n     * Impersonated Credentials allowing credentials issued to a user or\n     * service account to impersonate another. The source project using\n     * Impersonated Credentials must enable the \"IAMCredentials\" API.\n     * Also, the target service account must grant the orginating principal\n     * the \"Service Account Token Creator\" IAM role.\n     *\n     * @param {object} options - The configuration object.\n     * @param {object} [options.sourceClient] the source credential used as to\n     * acquire the impersonated credentials.\n     * @param {string} [options.targetPrincipal] the service account to\n     * impersonate.\n     * @param {string[]} [options.delegates] the chained list of delegates\n     * required to grant the final access_token. If set, the sequence of\n     * identities must have \"Service Account Token Creator\" capability granted to\n     * the preceding identity. For example, if set to [serviceAccountB,\n     * serviceAccountC], the sourceCredential must have the Token Creator role on\n     * serviceAccountB. serviceAccountB must have the Token Creator on\n     * serviceAccountC. Finally, C must have Token Creator on target_principal.\n     * If left unset, sourceCredential must have that role on targetPrincipal.\n     * @param {string[]} [options.targetScopes] scopes to request during the\n     * authorization grant.\n     * @param {number} [options.lifetime] number of seconds the delegated\n     * credential should be valid for up to 3600 seconds by default, or 43,200\n     * seconds by extending the token's lifetime, see:\n     * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n     * @param {string} [options.endpoint] api endpoint override.\n     */\n    constructor(options = {}) {\n        var _a, _b, _c, _d, _e, _f;\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: 'impersonated-placeholder',\n        };\n        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : '';\n        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n        const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get('universe_domain');\n        if (!usingExplicitUniverseDomain) {\n            // override the default universe with the source's universe\n            this.universeDomain = this.sourceClient.universeDomain;\n        }\n        else if (this.sourceClient.universeDomain !== this.universeDomain) {\n            // non-default universe and is not matching the source - this could be a credential leak\n            throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);\n        }\n        this.endpoint =\n            (_f = options.endpoint) !== null && _f !== void 0 ? _f : `https://iamcredentials.${this.universeDomain}`;\n    }\n    /**\n     * Signs some bytes.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}\n     * @param blobToSign String to sign.\n     *\n     * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string\n     */\n    async sign(blobToSign) {\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:signBlob`;\n        const body = {\n            delegates: this.delegates,\n            payload: Buffer.from(blobToSign).toString('base64'),\n        };\n        const res = await this.sourceClient.request({\n            ...Impersonated.RETRY_CONFIG,\n            url: u,\n            data: body,\n            method: 'POST',\n        });\n        return res.data;\n    }\n    /** The service account email to be impersonated. */\n    getTargetPrincipal() {\n        return this.targetPrincipal;\n    }\n    /**\n     * Refreshes the access token.\n     */\n    async refreshToken() {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            await this.sourceClient.getAccessToken();\n            const name = 'projects/-/serviceAccounts/' + this.targetPrincipal;\n            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n            const body = {\n                delegates: this.delegates,\n                scope: this.targetScopes,\n                lifetime: this.lifetime + 's',\n            };\n            const res = await this.sourceClient.request({\n                ...Impersonated.RETRY_CONFIG,\n                url: u,\n                data: body,\n                method: 'POST',\n            });\n            const tokenResponse = res.data;\n            this.credentials.access_token = tokenResponse.accessToken;\n            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n            return {\n                tokens: this.credentials,\n                res,\n            };\n        }\n        catch (error) {\n            if (!(error instanceof Error))\n                throw error;\n            let status = 0;\n            let message = '';\n            if (error instanceof gaxios_1.GaxiosError) {\n                status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n                message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n            }\n            if (status && message) {\n                error.message = `${status}: unable to impersonate: ${message}`;\n                throw error;\n            }\n            else {\n                error.message = `unable to impersonate: ${error}`;\n                throw error;\n            }\n        }\n    }\n    /**\n     * Generates an OpenID Connect ID token for a service account.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n     *\n     * @param targetAudience the audience for the fetched ID token.\n     * @param options the for the request\n     * @return an OpenID Connect ID token\n     */\n    async fetchIdToken(targetAudience, options) {\n        var _a, _b;\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n        const body = {\n            delegates: this.delegates,\n            audience: targetAudience,\n            includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true,\n            useEmailAzp: (_b = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _b !== void 0 ? _b : true,\n        };\n        const res = await this.sourceClient.request({\n            ...Impersonated.RETRY_CONFIG,\n            url: u,\n            data: body,\n            method: 'POST',\n        });\n        return res.data.token;\n    }\n}\nexports.Impersonated = Impersonated;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}